# 通信設計の再検討結果

## 検討観点
1. 参加登録人数のリアルタイム把握は不要（アプリの動作が重くなることを避ける）
2. 進行側の待機人数表示はボタン押下時の状態確認で十分
3. ゲーム中のカード選択はリアルタイム更新が望ましい（タイマー終了直前の変更に対応）

## 各機能の実装方針

### 1. 参加人数の取得
**要件**: 進行側がボタンを押下した時点での待機人数を表示

**実装方針**:
- リアルタイム監視は行わない
- 「待機人数更新」ボタン押下時に `GET /api/participants/count` を呼び出し
- 通常のHTTPリクエストで実現

**メリット**:
- サーバー負荷が軽い
- 実装が簡単
- 不要な通信を削減

---

### 2. ゲーム開始トリガー
**要件**: 進行側がボタンを押すと、参加者側でカウントダウンが開始

**実装方針**:
- 進行側: `POST /api/game/start` でゲーム状態を「countdown」に変更、開始時刻を記録
- 参加者側: 待機中は1秒間隔で `GET /api/game/state` をポーリング
- 状態が「countdown」に変わったら、カウントダウン開始
- ゲーム中（countdown/playing）はポーリングを停止

**メリット**:
- WebSocket/SSEが不要（軽量）
- 実装が簡単
- 待機中のみポーリングするため、負荷が低い

**注意点**:
- 最大1秒の遅延が発生する可能性（許容範囲内と判断）

---

### 3. カード選択の処理
**要件**: 参加者の操作でリアルタイム更新が望ましい（タイマー終了直前の変更に対応）

**実装方針**:
- 参加者側: カード選択時に即座に `POST /api/game/select` を送信
- 参加者側: 選択状態はクライアント側で即座に視覚的に更新（黄緑色、1.2倍拡大）
- 進行側: リアルタイム反映は不要。結果発表時に `GET /api/results` で取得

**タイマー終了直前の選択変更への対応**:
- サーバー側でタイマー終了時刻を記録（開始時刻 + 3秒（カウントダウン）+ 20秒（ゲーム時間））
- 選択情報の保存時にサーバー側の受信時刻（タイムスタンプ）を記録
- 結果取得時に有効な選択のみを取得（終了時刻以前の選択のみを有効とし、同じ参加者の複数の選択がある場合は最新のものを採用）
- これにより、タイマー終了直前（残り0.1~1秒）の選択変更も正しく取得できる

**メリット**:
- 参加者側は即座に視覚的フィードバックが得られる
- 進行側へのリアルタイム反映が不要なため、サーバー負荷が軽い
- 結果発表時に一括取得するため、実装が簡単
- タイマー終了直前の選択変更も正しく反映される

**注意点**:
- 進行側はゲーム中に選択状況を確認できないが、要件上問題なし
- サーバー側の受信時刻を基準にするため、クライアントとサーバーの時刻差を考慮する必要がない

---

### 4. タイマー同期
**要件**: 参加者側と進行側でタイマーを同期

**実装方針**:
- サーバー: ゲーム開始時に開始時刻を記録
- 参加者側: ゲーム状態が「countdown」になったら、開始時刻を取得し、クライアント側でタイマーを計算
- 進行側: 同様に開始時刻を取得し、クライアント側でタイマーを計算

**メリット**:
- サーバー負荷が軽い（開始時刻の記録のみ）
- クライアント側でタイマー管理するため、精度が高い

---

## 結論

### WebSocket/SSEは不要
以下の理由により、WebSocketやServer-Sent Eventsによるリアルタイム通信は実装しない：

1. **参加人数取得**: ボタン押下時のHTTPリクエストで十分
2. **ゲーム開始**: ポーリング（1秒間隔、待機中のみ）で実現可能
3. **カード選択**: 参加者側は即座にPOST送信、進行側は結果発表時に取得で十分
4. **タイマー同期**: 開始時刻をサーバーから取得し、クライアント側で計算

### 実装方式
- **待機中**: 参加者側が1秒間隔でポーリング
- **ゲーム中**: ポーリング停止（クライアント側でタイマー管理）
- **カード選択**: 即座にPOST送信
- **結果取得**: 進行側が結果発表時にGETで取得

### メリット
- サーバー負荷が軽い
- 実装が簡単
- 不要な通信を削減
- アプリの動作が重くならない

